## Обзор диссертации Джо Армстронга (Joe Armstrong). Making reliable distributed systems in the presence of software errors. 2003

Основным вопросом диссертации является задача построения надежных систем из программ, которые могут содержать ошибки. Построение таких систем налагает некоторые требования к используемому языку программирования. В диссертации рассмотрены эти требования и показано как они выполняются языком программирования Erlang. 


### Архитектурная модель
Во второй главе рассматривается архитектура необходимая для создания отказоустойчивых систем.
Основными характеристиками такой архитектуры являются:
- Предметная область (архитектура зависит от решаемых проблем)
- Философия (центральные идеи архитектуры, объяснение метода построения программы)
- Набор методических рекомендаций по построению (нужны чтобы все программисты и другие вовлеченные люди понимали архитектуру)
- Набор предопределенных компонентов (потому что из компонентов проще строить, чем с нуля)
- Способ конфигурирования
- Метод описания (протоколов, интерфейсов, структур и т.д.)

Одним из наиболее интересных моментов в диссертации оказался для меня подраздел, описывающий философию архитектуры:
> Мы организуем приложение как иерархию задач, которые система должны выполнять. Каждая задача соответствует достижению некоторых целей.
Задачи стуктурированы по степени сложности. Задача высшего уровня наиболее сложная. Когда все цели задачи высшего уровня достигаются, значит система работает идеальным образом. Задачи нижних уровней должны позволять системе работать приемлемым образом, но с урезанным функционалом.
Цели задач нижнего уровня должны быть более легко достижимы, чем задачи высокого уровня.
Приложени пытается выполнить задачу наивысшего уровня. Если обнаруживается ошибка, то предпринимается попытка её исправить, если она не может быть исправлена немеделенно, то начинает выполняться более простая задача.

Создание иерархии задач нуждается в сильной инкапсуляции, для изоляции ошибок. Обычно, для обеспечения такой изоляции используются процессы предоставляемые операционной системой. Но в erlang системные процессы и параллелизм являются частью языка. Это в свою очередь даёт следующие преимущества: 1) параллельные программы работают идентично независимо от ОС 2) процессы значительно более легковесны 3) мало зависимостей от ОС

Приложения в erlang структурированы по средством большого числа взаимодействующих параллельных процессов. Такой подход используется по ряду причина, главная из которых - отказоустойчивость.
Как только два процесса делят любой общий ресурс, например, память или указатель на память, то существует возможность программной ошибки в одном из процессов, которая повредит этот ресурс. Исправление таких ошибок в больших системах является неразрешимой проблемой и, по мнению Армстронга, единственный реалистичный способ построения больших надежных систем - это разделение системы на независимые параллельные процессы, а также наличие механизма их мониторинга и перезапуска.

### Параллельное программирование /  Concurrency oriented programming (COP)
COP предоставляет две возможности, которые обычно ассоциируются с объектно-ориентированным программированием: полиморфизм и использованием протоколов, обеспечивающих интерфейс передачи сообщений между процессами разных типов. Когда мы разбиваем проблему на отдельные параллельные процессы, мы можем сделать так чтобы все они отвечали на одинаковые сообщения.

Ещё одной интересной и неочевидной для меня идеей стала идея "программировать наблюдая за реальным миром".
Обычно, мы хотим создавать программы, моделирующие мир или взаимодействующие с ним. Написать такие программы в паралелльно-ориентированном стиле просто. Нужно провести трехшаговый анализ:
1) Определить все виды деятельности, которые происходят паралелльно в мире.
2) Определить все каналы сообщений между ними.
3) Записать все сообщения, передающиеся между разными каналами.

Структура программы должна точно следовать стуктуре процессов в реальном мире. Каждый процесс из реального мира должен стать отдельным процессом программы. Это очень важно, для того чтобы сделать понимание решения и проблемы, для которой оно созданно, более прозрачным.

#### Характеристики Concurrency oriented programming language (COPL) 
1.  COPL должен поддерживать процессы. Процесс может представляться как 
автономная виртуальная машина.
2. Несколько процессов запущенных на одном компьютере должны быть сильно изолированы. Неполадки в одном процесс не должны негативно влиять на другой процесс, кроме случая, когда их взаимодействие специально запрограммировано.
3. Каждый процесс должен иметь уникальный идентификатор (pid).
4. Процессы не должны иметь общих ресурсов. Взаимодействие осуществляется только с помощью сообщений. Если pid  процесса известен, то ему можно отправить сообщение.
5. Нет гарантий доставки сообщений.
6. У процесса должна быть возможность определять сбои в других процессах. Также должна быть возможность узнать причину сбоя.

### Техники программирования
В четвёртой главе диссертации приводятся рекомендуемые техники программирования.
1) Создание абстракций с целью разбиения кода на параллельный и последовательный. Наиболее опытным программистам предлагается создавать generic модули, которые обрабатывают параллельное взаимодействие, а остальные программисты могут писать последовательный код и встраивать его в качестве плагинов.
2) Взгляд на ошибки в erlang:
- Позволить процессам восстанавливать другие процессы после ошибок.
- Позволить процессу умереть, если он не может сделать, что нужно.
- Не использовать защитное программирование.
3) Преднамеренное программирование (Intentional programming). Предполагается  получение информации о коде из названий, а не посредством анализа кода.

### Создание систем устойчивых к ошибкам
В пятой главе Армстронг предлагает следующее определение *системы устойчивой к ошибкам*:
Это такая система, которая может нормально выполняться несмотря на возникновение логических ошибок.

Также в этой главе рассматриваются:
- Стратегия для программирования систем устойчивой к ошибкам (немедленно падать, если ошибка не может быть исправлена и пытаться выполнить более простую задачу).
- Иерархии супервизоров.
- Well-behaved functions (функции, которые предположительно работают корректно. Возникающие в них исключения трактуются как сбой).

###  API и протоколы
В девятой главе автор рассуждает над вопросом "что лучше выбрать для описания модуля?". И приходит к выводу, что протокол лучше:
Очень полезно взглянуть на систему снаружи и рассмотреть её как набор общающихся чёрных ящиков. Если описать формально протокол, которому должны следовать коммуницирующие каналы между двумя чёрными ящиками, тогда можно использовать его для обнаружения ошибок и точно определять какой компонент является источником ошибки.

### Итоги
В последней главе автор подводит итоги:
- Erlang и сопутствующие технологии работают. Это подтверждается примерами приведёнными в восьмой главе.
- Использование легковесных процессов и отказ от общих ресурсов работают на практике и позволяют создавать большие промышленные системы.
- Возможно создавать системы, работающие разумным образом, даже при возникновении ошибок. 

Автор приводит интересное наблюдение о способе создания интернет приложений. 
Для этого используются:
- Изолированные компоненты.
- Обмен сообщениями.
- Неформальные протоколы.

В завершение автор пишет:
> Я верю, что модель программирования одноузловых приложений должна быть такой же как и для распределённых приложений. Различные компоненты должны быть защищены друг от друга процессами. Должна отсутствовать возможность повреждения процессов друг другом, они должны общаться используя определенные протоколы закрепленные в контрактах и обеспечиваемые проверками. 
